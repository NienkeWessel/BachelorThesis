As computers are found almost everywhere nowadays, we would hope these computers would always do as we expect them to do. However, so far very few programs and programming languages have actually been proven correct. Intensive testing is the best most software developers can do. Luckily, much work is being done on the more rigorous \emph{proving} that a computer program does what it is designed to do. This thesis aims to join in those efforts. 

The thesis is about the Rust programming language \citep{matsakis2014rust}. The makers of this programming language have made several claims about the safety, and specifically memory safety, of their language. Among other things, it should be impossible to get data races or dangling pointers in your programs. All safety aspects are guaranteed compile time; if your Rust program contains hazards, the compiler will reject the program. This means that all checks should be able to happen even if the actual program, for example, contains an infinite loop. Due to executing these checks compile time, no runtime penalty should exist. This is also the reason it has been argued that Rust is a good language to use to, for example, write a kernel \citep{levy2017kernel} or to use in combination with other security measures such as Software Guard Extensions \citep{ding2017sgx}. Other benefits beyond memory safety have also been attributed to Rust and the way it works \citep{balasubramanian2017system}.

\section{Previous work}
However, so far, little has been done to actually verify all the claims made by the developers of Rust. Much of the previous work concerning Rust has been done on improving the language itself and making it more versatile. See for example \cite{jespersen2015session}. Little has been done to actually confirm that it all works. 

The most notable project that does look into the actual memory safety of Rust, is the Rustbelt project \citep{jung2017rustbelt}. In this project, researchers have formalized a subset of Rust and proved some libraries to be safe in Coq. They use separation logic in order to model the memory of the computer during computation. 

\cite{benitez2016rusty} has also made a formalization of a very small subset of Rust. They modelled references and ownership as capabilities on different value locations. For example, a variable \verb|x| could have the capabilities \texttt{read} or \texttt{write} on a location to indicate that it could be read or modified respectively. They separated memory locations from computation. In \cite{reed2015patina} something similar is done, and some memory safety claims are proven. 

\section{The current work}
The current work aims to differentiate from the above work by showing how we can model the memory safety aspects of Rust, while using simple semantic rules, instead of more advanced tactics such as separation logic. The proofs here should be readable for anyone with only basic background in semantics theory, and should give the reader insight into what is happening in Rust both in practice and on a formal level. 

The research question that is central in this thesis is \emph{How does one formally describe ownership in Rust in a simple way?}

In order to answer this question, we looked at several subquestions:

\begin{itemize}[noitemsep]
    \item What is ownership in Rust?
    \begin{itemize}[noitemsep]
        \item What is it used for?
        \item What syntax is relevant to denote ownership?
        \item What are lifetimes?
        \item What do lifetimes have to do with ownership?
    \end{itemize}
    \item What subset of Rust is necessary to describe ownership?
    \item What type of semantics is the most useful to describe ownership?
    \item How can we model the compile time checker best?
    \item Can we actually prove memory safety from a set of semantics rules and a compile time checker?
\end{itemize}


%In a world where almost everything around us uses computers it seems more than logical that we know that these computers behave like we expect them to. We don't want the bank to transfer a thousand dollars out of our account by accident or our computer with valuable documents to crash. However, most of the programs that you will use are not as verified as you would like. This thesis aims to help build the theory surrounding verification of programs from a semantics and type systems point of view. I focus on the programming language Rust, and then specifically its claims to be memory safe. I will show a way to formalize the language and will prove several stuff about it.  

%Is this thesis useful for practical things
%Hoe verhoudt deze scriptie zich tot RustBelt

%This question is then divided in several subquestions, such as one for the syntax, one for the semantics, one for the type system.



\section{Scope of this thesis}
As for Rust, we will only be focussing on two major aspects of the language; the concepts of \emph{ownership} and \emph{borrowing}. All you need to know and a little bit more is explained in chapter \ref{Rust}. The version of Rust compiler used for this thesis was 1.22.1. 

We will mainly leave the types for what they are and focus on the memory safety aspect. The specific types do not bear anything interesting compared to other programming languages and therefore are ignored to keep the scope of this thesis limited. We will look at whether an item is \texttt{mut}able or not, a concept explained in chapter \ref{Rust}. 

Rust also offers the possibility to surpass most of its memory safety guards by giving the user the option to use \texttt{unsafe} code. Many of Rust's standard libraries depend on \texttt{unsafe} code. However, the developers of Rust claim that if users just make use of the interfaces and do not write unsafe code themselves, their code should be safe. In this thesis, we will not look at unsafe code. \cite{jung2017rustbelt} has developed a set of semantic rules to incoorperate both safe and unsafe code. 

As for the compile time check, we want our compile time checker to always finish, even when the program does not do so, as is the case in the normal Rust compiler. Simply running the program is not an option therefore, there needs to be some abstraction, which we will offer. However, we will not follow the Rust compiler completely. The compiler often gives warnings, if there is something of which it suspects that you did not mean to write it down that way. We will ignore the warnings. Our goal here is to accept the same programs as the Rust compiler accepts, so we only take actual errors into account. 

\section{The next chapters}
After this chapter, we first have Chapter \ref{Rust}, where we explain the relevant aspects of Rust. After that, in Chapter \ref{Moving} \emph{Moving}, we will formalize the most basic form of the ownership concept. In this chapter, we will walk through all (mathematical) details rather thoroughly. In the chapter after that, Chapter \ref{Borrowing} \emph{Borrowing}, we will add two new features, those of mutability and borrowing. By then, we have a pretty rigorous basis from Chapter \ref{Moving}, so we will not provide as many details anymore. This gives us the space to actually focus on what is happening there, instead of getting lost in the maths. In the final chapter, Chapter \ref{Conclusion} Conclusion \& Discussion, we briefly discuss what we have done and the implications for future work. 
