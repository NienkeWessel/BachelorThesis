In the previous chapters, we have seen how ownership, borrowing and mutability work together to provide memory safety and how we write these concepts down in relatively simple semantic rules. We have also proved preservation and progress, to prove memory safety in a more classical way. 

\section{Discussion and future work}
While we have looked at some important concepts of Rust, there is of course many many more to Rust that we did not look at extensively. 

\subsection{While}
For example, we did not include loops in our very limited language, even though loops have been kept in mind while designing the derivation rules for both the semantics and compile time checker. 

It is interesting to add some form of looping, as that makes it for example possible for a program to not ever finish. As said in the introduction of this thesis, we want the compile time check to always finish, even if the program itself does not finish. 

For example, the very simple program 

\begin{minted}[linenos, frame=lines]{rust}
fn main() {
    while true {
        print!("Hello world!")
    }
}
\end{minted}

produces no error. \footnote{It does give the warning \texttt{denote infinite loops with `loop { ... }`}, but as said in the introduction, we will only be trying to model actual errors.}

During the making of the thesis, we briefly looked at how we could add while loops to our syntax. 

\begin{definition}
\label{statementswhile}
A statement $S$ is defined recursively by:
$$S ::= \textrm{skip} \mid S_1; S_2 \mid a: \textrm{let } x:\tau \textrm{ in } S' \mid x := e \mid \whi{S'}$$
where $e$ is an expression, $\tau$ is a type and $S_1$, $S_2$ and $S'$ are again statements.
\end{definition}

For a formal definition of Booleans $b$, we refer to \cite{nielson1992semantics}.

Besides this, we would have semantic rules of the following form. 

\begin{definition}
\label{oswhile}
In addition to the rules in \ref{osb}, we define the following two semantic derivation rules:

$$\sosb{\whi{S'}}{L}{s}{M} \Rightarrow \sosb{S'}{\whi{S'}::L}{s}{M}$$ 
if $b$ evaluates to \texttt{true}. (named [whilet$_{\textrm{os}}$])

$$\sosb{\whi{S'}}{L}{s}{M} \Rightarrow \sosb{\texttt{skip}}{L}{s}{M}$$ 
if $b$ evaluates to \texttt{false}. (named [whilef$_{\textrm{os}}$])
\end{definition}

Of course, the intersting part is how we will deal with the while loop in the compile time check. The Rust compiler simply does not accept any non-mutable variable assignments in a while loop, even if the assignment happens only once or not even at all, as in the following program.

\begin{minted}[linenos, frame=lines]{rust}
let x;
while false {
    x = 0
}
\end{minted}

This program gives the error \texttt{re-assignment of immutable variable `x}.

So we will have to keep track of whether we are in a while loop or not. We can do that for example by adding and extra little bit of information to our derivation system, so that our derivation system has rules of the form 

$$\ccwhile{S}{L}{s}{M}{b} \to \ccwhile{S'}{L'}{s'}{M'}{b'}$$

where $b$ and $b'$ are booleans that are either \texttt{true} or \texttt{false}. We use the boolean to indicate whether we are in a while loop or not. 

As a compile time checker, we would have something like in the following definition. 
\begin{definition}
\label{compiletimecheckerwhile}
The \emph{compile time checker} is a derivation system that has the following rules
\begin{align*}
\ccwhile{\texttt{skip}}{\texttt{Nil}}{r}{M}{b} & \to \texttt{true}  \\
\ccwhile{\texttt{skip}}{P::L}{r}{M}{b}      & \to \ccwhile{P}{L}{r}{M}{b}  \\
\ccwhile{S_1; S_2}{L}{r}{M}{b}                 & \to \ccwhile{S_1}{S_2::L}{r}{M}{b}  \\
\ccwhile{x:=e}{L}{r}{M}{b}                    & \to \ccwhile{\texttt{skip}}{L}{r[x\mapsto \star][\mathcal{V}(e) \mapsto -]}{M[\forall \textit{y} \in B(\textit{e}), \textit{y}\mapsto M(\textit{y})\cup \{\texttt{bor} \} ][\textit{x} \mapsto M(\textit{x}) \cup B(\textit{e})]}{b} \\
                                    & \textrm{if } \neg b, \texttt{mut} \in \mathcal{M}(x), r(x) = & \perp \textrm{ or } r(x) = \star, \\ &  \forall y \in \mathcal{C}(e), r(y) = \star \textrm{ and } \forall y \in \mathcal{B}(e), \neg \texttt{bor} \in \mathcal{M}(e) \\
                                    & \textrm{if } \neg b, \neg \texttt{mut} \in \mathcal{M}(x),  r(x) = \perp,  \\ & \forall y \in \mathcal{C}(e), r(y) = \star \textrm{ and } \forall y \in \mathcal{B}(e), \neg \texttt{bor} \in \mathcal{M}(e) \\
                                    & \textrm{if } b, \texttt{mut} \in \mathcal{M}(x), r(x) = \perp \textrm{ or } r(x) = \star, \forall y \in \mathcal{C}(e), r(y) = \star, \mathcal{B}(e) = \emptyset \textrm{ and } \mathcal{V}(e) = \emptyset \\
                                    & \to \texttt{false} \textrm{ otherwise}\\
\ccwhile{\letm{x}{S}}{L}{r}{M}{b} & \to \ccwhile{S}{(x,r(x),\mathcal{M}(x))::L}{r[x\mapsto \perp]}{M}{b} \\
\ccwhile{\letmut{x}{S}}{L}{r}{M}{b} & \to \ccwhile{S}{(x,r(x),\mathcal{M}(x))::L}{r[x\mapsto \perp]}{M[\texttt{x}\mapsto\{\texttt{mut}\}]}{b} \\
\ccwhile{(x,v,m)}{L}{r}{M}{b}                    & \to \ccwhile{\texttt{skip}}{L}{r[x \mapsto v]}{M[\forall \textit{y} \in M(\textit{x})\cap\textbf{Var}, \textit{y} \mapsto M(\textit{y}) \setminus \{\texttt{bor}\}][\texttt{x} \mapsto \textrm{m}]}{b} \\
\ccwhile{\whi{S}}{L}{r}{M}{b} & \to \ccwhile{S}{(b)::L}{r}{M}{\texttt{true}} \\
\ccwhile{(b')}{L}{r}{M}{b} & \to \ccwhile{\texttt{skip}}{L}{r}{M}{b'}
\end{align*}
\end{definition}
This definition honors that there should be no immutable assignment within a loop, as that would make it possible for an assignment to happen multiple times. Also, when entering a while loop, the boolean will be updated to state that we are in a while loop. At the end of the while loop, the boolean will have to be set back to what it was before. We cannot simply put it to \texttt{false}, as that we might have a while loop within a while loop. 

Now as for memory safety, this is a bit more difficult. Where previously, each semantic rule had a compile time check equivalent, which made proofs easy, we now have a more difficult situation where this is not the case. That is why we did not have the time to finish the proofs in this thesis. We will provide a brief sketch of the problems. 


\subsection{Lifetimes}
Due to time constraints, we did not really include lifetimes in this thesis. We mostly used scope properties instead of the lifetimes themselves. A more elaborate research should look into how to incorporate lifetimes in the current semantics. This would include choosing a suitable mathematical representation for lifetimes. 

A possible choice would be to make lifetimes a lattice. Not all lifetimes are necessarily comparable, but those within one function should be. There should be an upper bound and lower bound. 

Later research could look into this possibility. 

\subsection{Functions}
To make a usuable programming language, functions are very important. It seems likely that lifetimes will be needed to make a successful semantic implementation of this. 

