\section{Introduction}
We will now add an extra feature to our language, namely borrowing. Borrowing presents us with new challenges, as we need to make sure that the variable we borrow from is not accessible during the borrow, but becomes accessible again after the borrow. We will need to keep track of what variables we have borrowed from. If we do not do so, we cannot free them afterwards. 

\section{Syntax}
First, we need to update our syntax to reflect the possibility of borrowing. The possible statements from definition \ref{statementsmove} can remain the same. We will need to update our expressions.

\begin{definition}
\label{expressionsborrow}
An expression $e$ is defined recursively by:
$$e ::= x \mid i \mid e_1 + e_2 \mid \&a~e$$
\end{definition}

We will also need to update our types, to indicate that a variable can have an indirect type.

\begin{definition}
\label{typesborrow}
A type $\tau$ is
$$\tau ::= \textrm{Int} \mid \& \tau$$
\end{definition}

\section{A case study}

In order to illustrate what is happening in this chapter and therefore what should be happening in the semantics, we will walk through a small piece of example code, which we have also seen in \ref{desugar}. 

\begin{minted}[linenos, frame=lines]{rust}
let x = 0;
let z;
let y = &x;
z = y;
\end{minted}

If we write this in our syntax, we get: 

\begin{minted}[linenos, frame=lines]{rust}
a: {
    let x: Int in x = 0
    b: {
        let z: &Int in 
        c: {
            let y: &Int in
            y = & x;
            z = y;
        }
    }
}
\end{minted} 

Now let's look per step at what should be happening in the semantics. At the start, we have no borrows and every variable is undefined, i.e. $-$. Then we look at the code. 

\begin{minted}[linenos, frame=lines]{rust}
a: {
    let x: Int in 
\end{minted}

Like in the previous chapter, it seems wise to keep track of what variables have been initialized and which have not been. So lets make a state again as we did in the previous chapter to keep track of the values of the variables. So we will say \texttt{x} now is $\perp$ or $s(x) = \perp$.  

\begin{minted}[linenos, frame=lines]{rust}
a: {
    let x: Int in x = 0
\end{minted}

Obviously, we will now want \verb|x| to equal $0 \in \mathbb{Z}$. Now we move on to the next \verb|let|-statement.

\begin{minted}[linenos, frame=lines]{rust}
a: {
    let x: Int in x = 0
    b: {
        let z: &Int in
\end{minted}

Now \verb|z| has been initiazed. So we have $s(x) = 0$ and $s(z) = \perp$. For all other variables $v$, we have $s(v) = -$. 

\begin{minted}[linenos, frame=lines]{rust}
a: {
    let x: Int in x = 0
    b: {
        let z: &Int in 
        c: {
            let y: &Int in
\end{minted}

Now we also have $s(y) = \perp$.

\begin{minted}[linenos, frame=lines]{rust}
a: {
    let x: Int in x = 0;
    b: {
        let z: &Int in 
        c: {
            let y: &Int in
            y = & x;
\end{minted}





We will first start with defining the evaluation function $\mathcal{A}$. In order to do that, we also need to know the type of the state $s$. We can leave the evaluation function for the first three types of expressions the same as in the previous section. However, we need to think of what we want $\&a~e$ to evaluate to. There are two possible logical answers. We can let it evaluate to e itself, and thus let the result of the evaluation be a pointer of some sort in the model as well. We can also recursively calculate the evaluation of $e$ and set that as the evaluation of $\&a~e$ as well. This latter model thus does not model pointers as such. In the two sections below, both models are worked out and described. We will start with the latter model, which we will call the ``non-pointer'' model. After that, the ``pointer'' model will be described. 

\subsection{Non-pointer model}
In this model, a state $s$ is a function with signature $\textbf{Var} \to \mathbb{Z}_{ext}$, just as before. The evaluation function is defined as:
\begin{align*}
    \letterfunc{A}{i}s          &= \letterfunc{N}{i}
\\  \letterfunc{A}{x}s          &= s(x)
\\  \letterfunc{A}{e_1 + e_2}s  &= \letterfunc{A}{e_1}s + \letterfunc{A}{e_2}s
\\ \letterfunc{A}{\&a~x}s       &= \letterfunc{A}{x}s
\end{align*}
Notice it is the same as above, except for the added last line. 

However, besides the state that assigns a value to a variable, we also need a way to keep track of what variables \verb|x| borrows from. In a program such as 
\begin{minted}[linenos, frame=lines]{rust}
let y;
{
    let x;
    {
        y = 5;
        x = &y
        //do other stuff?
    }
}
\end{minted}
we need to return ownership to \verb|y| at the end of the inner brackets. However, at the end of the brackets, we have no easy way in natural semantics to see that when \verb|x| goes out of scope, it has borrowed from \verb|y|. Natural semantics does not know what happens in the brackets. Therefore we define a second function, $\mathcal{B}$, that when passed a variable \verb|x|, returns all the variables \verb|x| borrowed from. The signature of $\mathcal{B}$ is \textbf{Var} $\to \mathcal{P}(\textbf{Var})$. That means the signature of a rule becomes 

$$\langle S, s, \mathcal{B} \rangle \to s, \mathcal{B}$$

The semantics for this model now become:

\medskip
\begin{tabular}{p{5em}p{18em}p{13em}}
[skip$_{\textrm{ns}}$] &
\centering$\langle$ \texttt{skip} $, s, \mathcal{B} \rangle \to s, \mathcal{B}$ & \medskip\\

[comp$_{\textrm{ns}}$] &
\centering \AxiomC{$\langle S_1, s, \mathcal{B} \rangle \to s', \mathcal{B}' $}
\AxiomC{$\langle S_2, s', \mathcal{B}' \rangle \to s'', \mathcal{B}''$}
\BinaryInfC{$\langle S_1$; $S_2, s, \mathcal{B} \rangle \to s'', \mathcal{B}''$}
\DisplayProof \medskip& \\

[let$_{\textrm{ns}}$] &
\centering
\AxiomC{$\langle S, s[x\mapsto \perp], \mathcal{B} \rangle \to s', \mathcal{B}'$}
\UnaryInfC{$\langle a : \texttt{let x } : \tau \texttt{ in } S, s, \mathcal{B} \rangle \to s'[\mathcal{B}'(x) \mapsto s\mathcal{B}'(x)][x \mapsto s(x)], \mathcal{B}'[x \mapsto *]$}
\DisplayProof \medskip& \\

[ass$_{\textrm{ns}}$] &
\centering$\langle$ \texttt{x := } e$, s \rangle \to s[x \mapsto \letterfunc{A}{e}s][ev(e)\mapsto-]$ & if $\letterfunc{A}{x}s = \perp$, $\letterfunc{A}{e} \neq \perp$ and $\letterfunc{A}{e} \neq -$\medskip\\
\end{tabular} 


\subsection{Pointer model}



