Nowadays, pretty much everywhere around us there is a computer. Phones and pcs being the most obvious but there are also many smaller computers everywhere. It would be great if we could be certain that all these computers would always do exactly what they are supposed to do. Sadly, at the moment it is often not possible or feasible to actually prove that. Intensive testing is the most software developers often can do. That is not to say that there is not a lot of work being done on the more rigorous \emph{proving} that a computer program does what it is designed to do. This thesis aims to join in those efforts. 

Specifically, this thesis is about the programming language Rust \cite{matsakis2014rust}. The makers of this programming language have made several claims about the safety and specifically memory safety of their language. It should be impossible to get data races or dangling pointers for example. And this safety is all guaranteed compile time; if your Rust program contains hazards, the compiler will reject the program. This means that all checks should be able to happen even if the actual program, for example, contains an infinite loop. Due to doing these checks compile time, no runtime penalty should exist. That's why it has been argued that Rust is a good language to use to for example write a kernel \cite{levy2017kernel} or to use in combination with other security measures such as Software Guard Extensions \cite{ding2017sgx}. 

%In a world where almost everything around us uses computers it seems more than logical that we know that these computers behave like we expect them to. We don't want the bank to transfer a thousand dollars out of our account by accident or our computer with valuable documents to crash. However, most of the programs that you will use are not as verified as you would like. This thesis aims to help build the theory surrounding verification of programs from a semantics and type systems point of view. I focus on the programming language Rust, and then specifically its claims to be memory safe. I will show a way to formalize the language and will prove several stuff about it. 

The question central in this thesis is: \\
\emph{How does one formally describe ownership in Rust?}\\

In order to answer this question, several subquestions were formulated: 

\begin{itemize}[noitemsep]
    \item What is ownership in Rust?
    \begin{itemize}[noitemsep]
        \item What is it used for?
        \item What syntax is relevant to denote ownership?
        \item What are lifetimes?
        \item What do lifetimes have to do with ownership?
    \end{itemize}
    \item What grammar describes ownership relevant features best?
    \item What are the semantics of these grammar parts?
    \item What type system describes ownership best?
    \item Something with proofs
\end{itemize}

%Is this thesis useful for practical things
%Hoe verhoudt deze scriptie zich tot RustBelt


%This question is then divided in several subquestions, such as one for the syntax, one for the semantics, one for the type system.

\section{Previous work}
A lot of the previous work concerning Rust has been done on improving the language itself and making it more versatile, see for example \cite{jespersen2015session}.


\section{Scope of this thesis}
As for Rust, we will only be focussing on two major aspects of the language; the concepts of \emph{ownership} and \emph{borrowing}. All you need to know and a little bit more is explained in chapter \ref{Rust}. The version of Rust compiler used for this thesis was 1.22.1. 

We will mainly leave the types for what they are and focus on the memory safety aspect. The types do not bear anything interesting compared to other programming languages and therefore are ignored to keep the scope of this thesis limited. 

As for the compile time check, we want our compile time checker to actually finish 
