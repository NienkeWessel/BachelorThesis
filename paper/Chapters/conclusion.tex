In the previous chapters, we have seen how ownership, borrowing and mutability work together to provide memory safety and how we write these concepts down in relatively simple semantic rules. We have also proved preservation and progress, to prove memory safety in a more classical way. 

\section{Discussion and future work}
While we have looked at some important concepts of Rust, there is of course many many more to Rust that we did not look at extensively. 

\subsection{While}
For example, we did not include loops in our very limited language, even though loops have been kept in mind while designing the derivation rules for both the semantics and compile time checker. 

It is interesting to add some form of looping, as that makes it for example possible for a program to not ever finish. As said in the introduction of this thesis, we want the compile time check to always finish, even if the program itself does not finish. 

For example, the very simple program 

\begin{minted}[linenos, frame=lines]{rust}
fn main() {
    while true {
        print!("Hello world!")
    }
}
\end{minted}

produces no error. \footnote{It does give the warning \texttt{denote infinite loops with `loop { ... }`}, but as said in the introduction, we will only be trying to model actual errors.}

During the making of the thesis, we briefly looked at how we could add while loops to our syntax. 

\begin{definition}
\label{statementswhile}
A statement $S$ is defined recursively by:
$$S ::= \textrm{skip} \mid S_1; S_2 \mid a: \textrm{let } x:\tau \textrm{ in } S' \mid x := e \mid \whi{S'}$$
where $e$ is an expression, $\tau$ is a type and $S_1$, $S_2$ and $S'$ are again statements.
\end{definition}

For a formal definition of Booleans $b$, we refer to \cite{nielson1992semantics}.

Besides this, we would have semantic rules of the following form. 

\begin{definition}
\label{oswhile}
In addition to the rules in \ref{osb}, we define the following two semantic derivation rules:

$$\sosb{\whi{S'}}{L}{s}{M} \Rightarrow \sosb{S'}{\whi{S'}::L}{s}{M}$$ 
if $b$ evaluates to \texttt{true}. (named [whilet$_{\textrm{os}}$])

$$\sosb{\whi{S'}}{L}{s}{M} \Rightarrow \sosb{\texttt{skip}}{L}{s}{M}$$ 
if $b$ evaluates to \texttt{false}. (named [whilef$_{\textrm{os}}$])
\end{definition}

Of course, the intersting part is how we will deal with the while loop in the compile time check. The Rust compiler simply does not accept any non-mutable variable assignments in a while loop, even if the assignment happens only once or not even at all, as in the following program.

\begin{minted}[linenos, frame=lines]{rust}
let x;
while false {
    x = 0
}
\end{minted}

This program gives the error \texttt{re-assignment of immutable variable `x}.

So we will have to keep track of whether we are in a while loop or not. We can do that for example by adding and extra little bit of information to our derivation system, so that our derivation system has rules of the form 

$$\ccwhile{S}{L}{s}{M}{c} \to \ccwhile{S'}{L'}{s'}{M'}{c'}$$

We use the boolean to indicate whether we are in a while loop or not, but more about that later. 

We will not provide a complete definition for the whole checker, but will sketch what this definition will have to keep track off. 
%\begin{definition}
%\label{compiletimecheckerwhile}
%The \emph{compile time checker} is a derivation system that has the following rules
%\begin{align*}
%\ccwhile{\texttt{skip}}{\texttt{Nil}}{r}{M}{b} & \to \texttt{true}  \\
%\ccwhile{\texttt{skip}}{P::L}{r}{M}{b}      & \to \ccwhile{P}{L}{r}{M}{b}  \\
%\ccwhile{S_1; S_2}{L}{r}{M}{b}                 & \to \ccwhile{S_1}{S_2::L}{r}{M}{b}  \\
%\ccwhile{x:=e}{L}{r}{M}{b}                    & \to \ccwhile{\texttt{skip}}{L}{r[x\mapsto \star][\mathcal{V}(e) \mapsto -]}{M[\forall \textit{y} \in B(\textit{e}), \textit{y}\mapsto M(\textit{y})\cup \{\texttt{bor} \} ][\textit{x} \mapsto M(\textit{x}) \cup B(\textit{e})]}{b} \\
%                                    & \textrm{if } \neg b, \texttt{mut} \in \mathcal{M}(x), r(x) = %& \perp \textrm{ or } r(x) = \star, \\ &  \forall y \in \mathcal{C}(e), r(y) = \star \textrm{ and } \forall y \in \mathcal{B}(e), \neg \texttt{bor} \in \mathcal{M}(e) \\
%                                    & \textrm{if } \neg b, \neg \texttt{mut} \in \mathcal{M}(x),  r(x) = \perp,  \\ & \forall y \in \mathcal{C}(e), r(y) = \star \textrm{ and } \forall y \in \mathcal{B}(e), \neg \texttt{bor} \in \mathcal{M}(e) \\
%                                    & \textrm{if } b, \texttt{mut} \in \mathcal{M}(x), r(x) = \perp \textrm{ or } r(x) = \star, \forall y \in \mathcal{C}(e), r(y) = \star, \mathcal{B}(e) = \emptyset \textrm{ and } \mathcal{V}(e) = \emptyset \\
%                                    & \to \texttt{false} \textrm{ otherwise}\\
%\ccwhile{\letm{x}{S}}{L}{r}{M}{b} & \to \ccwhile{S}{(x,r(x),\mathcal{M}(x))::L}{r[x\mapsto \perp]}{M}{b} \\
%\ccwhile{\letmut{x}{S}}{L}{r}{M}{b} & \to \ccwhile{S}{(x,r(x),\mathcal{M}(x))::L}{r[x\mapsto \perp]}{M[\texttt{x}\mapsto\{\texttt{mut}\}]}{b} \\
%\ccwhile{(x,v,m)}{L}{r}{M}{b}                    & \to \ccwhile{\texttt{skip}}{L}{r[x \mapsto v]}{M[\forall \textit{y} \in M(\textit{x})\cap\textbf{Var}, \textit{y} \mapsto M(\textit{y}) \setminus \{\texttt{bor}\}][\texttt{x} \mapsto \textrm{m}]}{b} \\
%\ccwhile{\whi{S}}{L}{r}{M}{b} & \to \ccwhile{S}{(b)::L}{r}{M}{\texttt{true}} \\
%\ccwhile{(b')}{L}{r}{M}{b} & \to \ccwhile{\texttt{skip}}{L}{r}{M}{b'}
%\end{align*}
%\end{definition}
First of all, we need to make sure that the compile time checker does not actually run through the while loop, as this might result in an infinite loop, while the checker itself should always finish. This calls for a rule of form similar to

$$\ccwhile{\whi{S}}{L}{r}{M}{c} \to \ccwhile{S}{\texttt{dec}::L}{r}{M}{c+1}$$

It is important that there should be no immutable assignment within a loop, as that would make it possible for an assignment to happen multiple times. As we saw before, the compile checker of the actual Rust Programming Language does not keep track of whether an assignment actually will happen multiple times, so  neither do we. This simplifies the process. 

We will need some way to keep track of whether we are in a while loop. Our proposal is to add an extra variable, a counter, in the tuple that will be incremented once we enter a while loop and decremented once we exit the while loop. If the compile time checker comes accross an immutable assignment when the counter is strict larger than zero, it should reject the program. 

The compile time checker pushes a decrease opertaion to our stack/list to make sure that after the while loop finishes, the counter will be reduced by one. 

We need a counter and cannot simply do with for example a boolean, as there might be multiple nested while loops. After the inner while loop, you might naively put the boolean to false when you finish, but then this would not be correct as you are still in the outer while loops. You could make an extra program instruction with the value of the boolean when you enter the loop to keep track of what it was, but this is extra bookkeeping and more difficult than our proposed solution.

The progress and preservation proofs get more complicated when we add while loops to our language. This is because our semantic rules no longer match as perfect with our compile time check anymore as in the previous chapters. This will mean we will have to do some extra work, or adjust our theorems. The compile time checker has an instruction that is not included in the semantics, so that we will need to adjust for that. 

\subsection{Lifetimes}
Due to time constraints, we did not really include lifetimes in this thesis. We mostly used scope properties instead of the lifetimes themselves. A more elaborate research should look into how to incorporate lifetimes in the current semantics. This would include choosing a suitable mathematical representation for lifetimes. 

A possible choice would be to make lifetimes a lattice. Not all lifetimes are necessarily comparable, but those within one function should be. There should be an upper bound and lower bound. 

Later research could look into this possibility. 

\subsection{Functions}
To make a usuable programming language, functions are very important. From chapter \ref{Rust}, it seems likely that lifetimes will be needed to make a successful semantic implementation of this. Future research could look into this. 

